from collections import deque

def solution(board):
    dr = [-1, 0, 1, 0]                      # 상 우 하 좌
    dc = [0, 1, 0, -1]
    N = len(board)                          # 보드판의 길이
    cost = [[1e10] * N for _ in range(N)]   # 각 좌표로 이동하는데 발생하는 비용

    def BFS():
        q = deque([(0, 0, 0, -1)])          # 행 열 좌표, 해당 좌표로 오는데 발생한 비용, 이전에 진행하던 방향
        cost[0][0] = 0                      # 시작 좌표는 비용이 없음

        while q:
            y, x, price, d = q.popleft()
            
            for k in range(4):              # 4 방향 모두 탐색
                r = y + dr[k]
                c = x + dc[k]

                if 0 <= r < N and 0 <= c < N and board[r][c] != 1:          # 범위내이고 벽이 아니라면
                    if (d == -1 or d == k) and price + 100 <= cost[r][c]:   # 초기 시작이거나 방향이 같을때, 다음 좌표가 100 비용이 늘어나더라도, 지금의 경우가 더 낮은 비용일떄
                        cost[r][c] = price + 100
                        q.append((r, c, price + 100, k))                    
                    elif price + 600 <= cost[r][c] + 200:                   # 방향이 다르고, 추가적인 비용이 400 이하로 차이가 날때 (예외 상황)
                        cost[r][c] = price + 600
                        q.append((r, c, price + 600, k))

    BFS()

    return cost[N-1][N-1]       # 도착지점 비용 출력

print(solution([[0,0,0],[0,0,0],[0,0,0]]))
print(solution([[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0],[0,0,0,0,1,0,0,0],[0,0,0,1,0,0,0,1],[0,0,1,0,0,0,1,0],[0,1,0,0,0,1,0,0],[1,0,0,0,0,0,0,0]]))
print(solution([[0,0,1,0],[0,0,0,0],[0,1,0,1],[1,0,0,0]]))
print(solution([[0,0,0,0,0,0],[0,1,1,1,1,0],[0,0,1,0,0,0],[1,0,0,1,0,1],[0,1,0,0,0,1],[0,0,0,0,0,0]]))
print(solution([[0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 1, 1, 1, 0], [1, 0, 0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 0]]))